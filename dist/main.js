/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./node_modules/css-loader/dist/cjs.js!./src/styles/main.css":
/*!*******************************************************************!*\
  !*** ./node_modules/css-loader/dist/cjs.js!./src/styles/main.css ***!
  \*******************************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../node_modules/css-loader/dist/runtime/sourceMaps.js */ "./node_modules/css-loader/dist/runtime/sourceMaps.js");
/* harmony import */ var _node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../node_modules/css-loader/dist/runtime/api.js */ "./node_modules/css-loader/dist/runtime/api.js");
/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__);
// Imports


var ___CSS_LOADER_EXPORT___ = _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default()((_node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default()));
// Module
___CSS_LOADER_EXPORT___.push([module.id, `:root{
  --bg: #0f1216;
  --panel: #151a21;
  --muted: #c8d1dc;
  --text: #e9eef5;
  --accent: #6ea8ff;
  --accent-2: #8bffb0;
  --border: #273142;
  --radius: 14px;
  --shadow: 0 8px 24px rgba(0,0,0,.35);
  --shadow-soft: 0 2px 8px rgba(0,0,0,.25);
  --grid-gap: 16px;
}
*{box-sizing:border-box}
html,body{height:100%;background:var(--bg);color:var(--text);font:14px/1.5 system-ui,-apple-system,Segoe UI,Roboto,Inter,Arial}
a,button,[role="button"]{cursor:pointer}


html, body {
  height: 100%;
  margin: 0;
}

app-root {
  display: block;
  height: 100%;
}

main{
  display:grid;
  grid-template-rows: 240px 1fr;
  gap: var(--grid-gap);
  height: calc(100% - 64px);
  padding: var(--grid-gap);
}

.buffer, .work{
  background:var(--panel);
  border:1px solid var(--border);
  border-radius:var(--radius);
  box-shadow:var(--shadow-soft);
  overflow:hidden;
}

.buffer{height:240px}
.work{min-height:320px}`, "",{"version":3,"sources":["webpack://./src/styles/main.css"],"names":[],"mappings":"AAAA;EACE,aAAa;EACb,gBAAgB;EAChB,gBAAgB;EAChB,eAAe;EACf,iBAAiB;EACjB,mBAAmB;EACnB,iBAAiB;EACjB,cAAc;EACd,oCAAoC;EACpC,wCAAwC;EACxC,gBAAgB;AAClB;AACA,EAAE,qBAAqB;AACvB,UAAU,WAAW,CAAC,oBAAoB,CAAC,iBAAiB,CAAC,iEAAiE;AAC9H,yBAAyB,cAAc;;;AAGvC;EACE,YAAY;EACZ,SAAS;AACX;;AAEA;EACE,cAAc;EACd,YAAY;AACd;;AAEA;EACE,YAAY;EACZ,6BAA6B;EAC7B,oBAAoB;EACpB,yBAAyB;EACzB,wBAAwB;AAC1B;;AAEA;EACE,uBAAuB;EACvB,8BAA8B;EAC9B,2BAA2B;EAC3B,6BAA6B;EAC7B,eAAe;AACjB;;AAEA,QAAQ,YAAY;AACpB,MAAM,gBAAgB","sourcesContent":[":root{\r\n  --bg: #0f1216;\r\n  --panel: #151a21;\r\n  --muted: #c8d1dc;\r\n  --text: #e9eef5;\r\n  --accent: #6ea8ff;\r\n  --accent-2: #8bffb0;\r\n  --border: #273142;\r\n  --radius: 14px;\r\n  --shadow: 0 8px 24px rgba(0,0,0,.35);\r\n  --shadow-soft: 0 2px 8px rgba(0,0,0,.25);\r\n  --grid-gap: 16px;\r\n}\r\n*{box-sizing:border-box}\r\nhtml,body{height:100%;background:var(--bg);color:var(--text);font:14px/1.5 system-ui,-apple-system,Segoe UI,Roboto,Inter,Arial}\r\na,button,[role=\"button\"]{cursor:pointer}\r\n\r\n\r\nhtml, body {\r\n  height: 100%;\r\n  margin: 0;\r\n}\r\n\r\napp-root {\r\n  display: block;\r\n  height: 100%;\r\n}\r\n\r\nmain{\r\n  display:grid;\r\n  grid-template-rows: 240px 1fr;\r\n  gap: var(--grid-gap);\r\n  height: calc(100% - 64px);\r\n  padding: var(--grid-gap);\r\n}\r\n\r\n.buffer, .work{\r\n  background:var(--panel);\r\n  border:1px solid var(--border);\r\n  border-radius:var(--radius);\r\n  box-shadow:var(--shadow-soft);\r\n  overflow:hidden;\r\n}\r\n\r\n.buffer{height:240px}\r\n.work{min-height:320px}"],"sourceRoot":""}]);
// Exports
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (___CSS_LOADER_EXPORT___);


/***/ }),

/***/ "./node_modules/css-loader/dist/runtime/api.js":
/*!*****************************************************!*\
  !*** ./node_modules/css-loader/dist/runtime/api.js ***!
  \*****************************************************/
/***/ ((module) => {

"use strict";


/*
  MIT License http://www.opensource.org/licenses/mit-license.php
  Author Tobias Koppers @sokra
*/
module.exports = function (cssWithMappingToString) {
  var list = [];

  // return the list of modules as css string
  list.toString = function toString() {
    return this.map(function (item) {
      var content = "";
      var needLayer = typeof item[5] !== "undefined";
      if (item[4]) {
        content += "@supports (".concat(item[4], ") {");
      }
      if (item[2]) {
        content += "@media ".concat(item[2], " {");
      }
      if (needLayer) {
        content += "@layer".concat(item[5].length > 0 ? " ".concat(item[5]) : "", " {");
      }
      content += cssWithMappingToString(item);
      if (needLayer) {
        content += "}";
      }
      if (item[2]) {
        content += "}";
      }
      if (item[4]) {
        content += "}";
      }
      return content;
    }).join("");
  };

  // import a list of modules into the list
  list.i = function i(modules, media, dedupe, supports, layer) {
    if (typeof modules === "string") {
      modules = [[null, modules, undefined]];
    }
    var alreadyImportedModules = {};
    if (dedupe) {
      for (var k = 0; k < this.length; k++) {
        var id = this[k][0];
        if (id != null) {
          alreadyImportedModules[id] = true;
        }
      }
    }
    for (var _k = 0; _k < modules.length; _k++) {
      var item = [].concat(modules[_k]);
      if (dedupe && alreadyImportedModules[item[0]]) {
        continue;
      }
      if (typeof layer !== "undefined") {
        if (typeof item[5] === "undefined") {
          item[5] = layer;
        } else {
          item[1] = "@layer".concat(item[5].length > 0 ? " ".concat(item[5]) : "", " {").concat(item[1], "}");
          item[5] = layer;
        }
      }
      if (media) {
        if (!item[2]) {
          item[2] = media;
        } else {
          item[1] = "@media ".concat(item[2], " {").concat(item[1], "}");
          item[2] = media;
        }
      }
      if (supports) {
        if (!item[4]) {
          item[4] = "".concat(supports);
        } else {
          item[1] = "@supports (".concat(item[4], ") {").concat(item[1], "}");
          item[4] = supports;
        }
      }
      list.push(item);
    }
  };
  return list;
};

/***/ }),

/***/ "./node_modules/css-loader/dist/runtime/sourceMaps.js":
/*!************************************************************!*\
  !*** ./node_modules/css-loader/dist/runtime/sourceMaps.js ***!
  \************************************************************/
/***/ ((module) => {

"use strict";


module.exports = function (item) {
  var content = item[1];
  var cssMapping = item[3];
  if (!cssMapping) {
    return content;
  }
  if (typeof btoa === "function") {
    var base64 = btoa(unescape(encodeURIComponent(JSON.stringify(cssMapping))));
    var data = "sourceMappingURL=data:application/json;charset=utf-8;base64,".concat(base64);
    var sourceMapping = "/*# ".concat(data, " */");
    return [content].concat([sourceMapping]).join("\n");
  }
  return [content].join("\n");
};

/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js":
/*!****************************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js ***!
  \****************************************************************************/
/***/ ((module) => {

"use strict";


var stylesInDOM = [];
function getIndexByIdentifier(identifier) {
  var result = -1;
  for (var i = 0; i < stylesInDOM.length; i++) {
    if (stylesInDOM[i].identifier === identifier) {
      result = i;
      break;
    }
  }
  return result;
}
function modulesToDom(list, options) {
  var idCountMap = {};
  var identifiers = [];
  for (var i = 0; i < list.length; i++) {
    var item = list[i];
    var id = options.base ? item[0] + options.base : item[0];
    var count = idCountMap[id] || 0;
    var identifier = "".concat(id, " ").concat(count);
    idCountMap[id] = count + 1;
    var indexByIdentifier = getIndexByIdentifier(identifier);
    var obj = {
      css: item[1],
      media: item[2],
      sourceMap: item[3],
      supports: item[4],
      layer: item[5]
    };
    if (indexByIdentifier !== -1) {
      stylesInDOM[indexByIdentifier].references++;
      stylesInDOM[indexByIdentifier].updater(obj);
    } else {
      var updater = addElementStyle(obj, options);
      options.byIndex = i;
      stylesInDOM.splice(i, 0, {
        identifier: identifier,
        updater: updater,
        references: 1
      });
    }
    identifiers.push(identifier);
  }
  return identifiers;
}
function addElementStyle(obj, options) {
  var api = options.domAPI(options);
  api.update(obj);
  var updater = function updater(newObj) {
    if (newObj) {
      if (newObj.css === obj.css && newObj.media === obj.media && newObj.sourceMap === obj.sourceMap && newObj.supports === obj.supports && newObj.layer === obj.layer) {
        return;
      }
      api.update(obj = newObj);
    } else {
      api.remove();
    }
  };
  return updater;
}
module.exports = function (list, options) {
  options = options || {};
  list = list || [];
  var lastIdentifiers = modulesToDom(list, options);
  return function update(newList) {
    newList = newList || [];
    for (var i = 0; i < lastIdentifiers.length; i++) {
      var identifier = lastIdentifiers[i];
      var index = getIndexByIdentifier(identifier);
      stylesInDOM[index].references--;
    }
    var newLastIdentifiers = modulesToDom(newList, options);
    for (var _i = 0; _i < lastIdentifiers.length; _i++) {
      var _identifier = lastIdentifiers[_i];
      var _index = getIndexByIdentifier(_identifier);
      if (stylesInDOM[_index].references === 0) {
        stylesInDOM[_index].updater();
        stylesInDOM.splice(_index, 1);
      }
    }
    lastIdentifiers = newLastIdentifiers;
  };
};

/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/insertBySelector.js":
/*!********************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/insertBySelector.js ***!
  \********************************************************************/
/***/ ((module) => {

"use strict";


var memo = {};

/* istanbul ignore next  */
function getTarget(target) {
  if (typeof memo[target] === "undefined") {
    var styleTarget = document.querySelector(target);

    // Special case to return head of iframe instead of iframe itself
    if (window.HTMLIFrameElement && styleTarget instanceof window.HTMLIFrameElement) {
      try {
        // This will throw an exception if access to iframe is blocked
        // due to cross-origin restrictions
        styleTarget = styleTarget.contentDocument.head;
      } catch (e) {
        // istanbul ignore next
        styleTarget = null;
      }
    }
    memo[target] = styleTarget;
  }
  return memo[target];
}

/* istanbul ignore next  */
function insertBySelector(insert, style) {
  var target = getTarget(insert);
  if (!target) {
    throw new Error("Couldn't find a style target. This probably means that the value for the 'insert' parameter is invalid.");
  }
  target.appendChild(style);
}
module.exports = insertBySelector;

/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/insertStyleElement.js":
/*!**********************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/insertStyleElement.js ***!
  \**********************************************************************/
/***/ ((module) => {

"use strict";


/* istanbul ignore next  */
function insertStyleElement(options) {
  var element = document.createElement("style");
  options.setAttributes(element, options.attributes);
  options.insert(element, options.options);
  return element;
}
module.exports = insertStyleElement;

/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js ***!
  \**********************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


/* istanbul ignore next  */
function setAttributesWithoutAttributes(styleElement) {
  var nonce =  true ? __webpack_require__.nc : 0;
  if (nonce) {
    styleElement.setAttribute("nonce", nonce);
  }
}
module.exports = setAttributesWithoutAttributes;

/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/styleDomAPI.js":
/*!***************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/styleDomAPI.js ***!
  \***************************************************************/
/***/ ((module) => {

"use strict";


/* istanbul ignore next  */
function apply(styleElement, options, obj) {
  var css = "";
  if (obj.supports) {
    css += "@supports (".concat(obj.supports, ") {");
  }
  if (obj.media) {
    css += "@media ".concat(obj.media, " {");
  }
  var needLayer = typeof obj.layer !== "undefined";
  if (needLayer) {
    css += "@layer".concat(obj.layer.length > 0 ? " ".concat(obj.layer) : "", " {");
  }
  css += obj.css;
  if (needLayer) {
    css += "}";
  }
  if (obj.media) {
    css += "}";
  }
  if (obj.supports) {
    css += "}";
  }
  var sourceMap = obj.sourceMap;
  if (sourceMap && typeof btoa !== "undefined") {
    css += "\n/*# sourceMappingURL=data:application/json;base64,".concat(btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))), " */");
  }

  // For old IE
  /* istanbul ignore if  */
  options.styleTagTransform(css, styleElement, options.options);
}
function removeStyleElement(styleElement) {
  // istanbul ignore if
  if (styleElement.parentNode === null) {
    return false;
  }
  styleElement.parentNode.removeChild(styleElement);
}

/* istanbul ignore next  */
function domAPI(options) {
  if (typeof document === "undefined") {
    return {
      update: function update() {},
      remove: function remove() {}
    };
  }
  var styleElement = options.insertStyleElement(options);
  return {
    update: function update(obj) {
      apply(styleElement, options, obj);
    },
    remove: function remove() {
      removeStyleElement(styleElement);
    }
  };
}
module.exports = domAPI;

/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/styleTagTransform.js":
/*!*********************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/styleTagTransform.js ***!
  \*********************************************************************/
/***/ ((module) => {

"use strict";


/* istanbul ignore next  */
function styleTagTransform(css, styleElement) {
  if (styleElement.styleSheet) {
    styleElement.styleSheet.cssText = css;
  } else {
    while (styleElement.firstChild) {
      styleElement.removeChild(styleElement.firstChild);
    }
    styleElement.appendChild(document.createTextNode(css));
  }
}
module.exports = styleTagTransform;

/***/ }),

/***/ "./src/components/app-root.js":
/*!************************************!*\
  !*** ./src/components/app-root.js ***!
  \************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _controls_bar_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./controls-bar.js */ "./src/components/controls-bar.js");
/* harmony import */ var _controls_bar_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_controls_bar_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _buffer_zone_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./buffer-zone.js */ "./src/components/buffer-zone.js");
/* harmony import */ var _buffer_zone_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_buffer_zone_js__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _work_zone_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./work-zone.js */ "./src/components/work-zone.js");
/* harmony import */ var _work_zone_js__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_work_zone_js__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _store_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../store.js */ "./src/store.js");
/* harmony import */ var _utils_polygen_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../utils/polygen.js */ "./src/utils/polygen.js");







class AppRoot extends HTMLElement {
  connectedCallback() {
    this.attachShadow({ mode: 'open' });
    this.shadowRoot.innerHTML = `
      <style>
        :host { 
          display: grid;
          grid-template-rows: auto 1fr;
          height: 100vh;
          min-height: 0;
          --header-h: 0px;
          --sep: 1px;
        }

        header { 
          padding: 12px 16px;
          border-bottom: 1px solid var(--border, #2b3342);
          background: linear-gradient(0deg, var(--panel, #151a21), #11161f);
          color: var(--text, #e9eef5);
        }
       
        main { 
          display: grid;
          grid-template-rows: 220px 1fr; 
          height: calc(100% - var(--header-h));
          border: none;
          background: var(--bg, #0f1216);
          position: relative;
          min-height: 0;
        }
       
        .buffer{
          position: relative;
          background: var(--panel, #151a21);
        }

        .buffer::after{
          content:"";
          position:absolute;
          left:0; right:0; bottom:0;
          height: var(--sep);
          pointer-events:none;
          background: linear-gradient(
            90deg,
            rgba(255,255,255,.10), 
            rgba(255,255,255,.06) 50%, 
            rgba(255,255,255,.10)
          );
          box-shadow: 0 0 6px rgba(110,168,255,.35);
        }

        .work{
          position: relative;
          background: var(--panel, #151a21);
          min-height: 0;
        }
          
      </style>
      <header><strong>Triumph</strong> · <controls-bar></controls-bar></header>
      <main>
        <buffer-zone class="buffer"></buffer-zone>
        <work-zone class="work"></work-zone>
      </main>
    `;

    const header = this.shadowRoot.querySelector('header');
    this._setHeaderHeight = () => {
      // ceil, чтобы убрать дробные пиксели и возможный 1px вертикальный скролл
      const hh = Math.ceil(header.getBoundingClientRect().height);
      this.style.setProperty('--header-h', `${hh}px`);
    };
    this._setHeaderHeight();

    this._headerRO = new ResizeObserver(this._setHeaderHeight);
    this._headerRO.observe(header);
    window.addEventListener('resize', this._setHeaderHeight);

    this.addEventListener('polys:create', (e)=> {
      let polys;
      if (e.detail.type === 'convex') {
        polys = (0,_utils_polygen_js__WEBPACK_IMPORTED_MODULE_4__.makeManyConvex)();
      } else {
        polys = (0,_utils_polygen_js__WEBPACK_IMPORTED_MODULE_4__.makeManySimple)();
      }

      (0,_store_js__WEBPACK_IMPORTED_MODULE_3__.setBuffer)(polys);

      const bufferZone = this.shadowRoot.querySelector('buffer-zone');
      bufferZone.polygons = _store_js__WEBPACK_IMPORTED_MODULE_3__.store.buffer;
    });


    this.addEventListener('polys:save', ()=>console.log('save'));
    this.addEventListener('polys:reset', ()=>console.log('reset'));
  }
}
customElements.define('app-root', AppRoot);

/***/ }),

/***/ "./src/components/buffer-zone.js":
/*!***************************************!*\
  !*** ./src/components/buffer-zone.js ***!
  \***************************************/
/***/ (() => {

class BufferZone extends HTMLElement {
  connectedCallback() { 
    this.attachShadow({mode:'open'}); 
    this._polys = [];
    this._selectedId = null;
    this.render();
  }

  set polygons(v) {
   this._polys= v || [];
   this.render();
  }

  render() {
    const svgItems = this._polys.map(p => {
      const pointsStr = p.points.map(pt => `${pt.x},${pt.y}`).join(" ");
      
      const isSelected = this._selectedId === p.id;
      
      return `
        <svg width="120" height="90" viewBox="0 0 120 90" data-id="${p.id}">
          ${isSelected ? `
            <defs>
              <filter id="glow" height="150%" width="150%">
                <feDropShadow dx="0" dy="0" stdDeviation="6.5" flood-color="orange" flood-opacity="0.9"/>
              </filter>
            </defs>` : ''} 
        <polygon points="${pointsStr}" fill="${p.fill}" stroke="${p.stroke}" stroke-width="1" filter="${isSelected ? 'url(#glow)' : ''}"/>
        </svg>
      `;
    }).join(" ");

    this.shadowRoot.innerHTML = `
    <style>
      :host { 
        display: block; 
        padding: 8px; 
        overflow: auto; 
      }

      div[part="wrap"] { 
        position: relative; 
        display: flex; 
        flex-wrap: wrap;
      }

      svg { 
        pointer-events: auto;
        cursor: pointer;
        margin-right: 2px;
        margin-bottom: 3px; 
      }

    </style>
    <div part="wrap">
      ${svgItems || '<em>Нажмите «Создать»</em>'}
    </div>
    `;

    this.shadowRoot.querySelectorAll('svg').forEach(svg => {
      svg.addEventListener('click', () => {
        this._selectedId = svg.dataset.id;
        this.render();
      });

      svg.addEventListener('mousedown', e => {
        const polygon = this._polys.find(p => p.id === svg.dataset.id);
        const appRoot = this.getRootNode().host;
        const workZone = appRoot.shadowRoot.querySelector('work-zone'); 

        if(!workZone) return;

        const startX = e.clientX;
        const startY = e.clientY;
        let dragging = false;

        const onMouseMove = ev => {
          const dx = Math.abs(ev.clientX - startX);
          const dy = Math.abs(ev.clientY - startY);

          if(!dragging && (dx > 3 || dy > 3)) {
            dragging = true;
            workZone.startDragFromBuffer(ev, polygon);
            document.removeEventListener('mousemove', onMouseMove);
            document.removeEventListener('mouseup', onMouseUp);
          }
        };

        const onMouseUp = ev => {
          document.removeEventListener('mousemove', onMouseMove);
          document.removeEventListener('mouseup', onMouseUp);
        };

        document.addEventListener('mousemove', onMouseMove);
        document.addEventListener('mouseup', onMouseUp);
      });
    });
  }
}

customElements.define('buffer-zone', BufferZone);

/***/ }),

/***/ "./src/components/controls-bar.js":
/*!****************************************!*\
  !*** ./src/components/controls-bar.js ***!
  \****************************************/
/***/ (() => {

class ControlsBar extends HTMLElement {
  connectedCallback() {
    this.attachShadow({mode: 'open'});
    this.shadowRoot.innerHTML = `
      <style>
        button { margin-right: 8px; }
        select { margin-left: 12px; }
      </style>

      <button id="create">Создать</button>
      <button id="save">Сохранить</button>
      <button id="reset">Сбросить</button>
    
      <label>
        Тип:
        <select id="polyType">
          <option value="simple" selected>Обычные</option>
          <option value="convex">Выпуклые</option>
        </select>
      </label>
      `;

    const send = (type, detail={}) =>
      this.dispatchEvent( new CustomEvent(type,{detail,bubbles:true,composed:true}));

      this.shadowRoot.getElementById('create').onclick = () => {
        const type = this.shadowRoot.getElementById('polyType').value;
        send ('polys:create', { type });
      };

      this.shadowRoot.getElementById('save').onclick = () => send('polys:save');
      this.shadowRoot.getElementById('reset').onclick = () => send('polys:reset');
  }
}
customElements.define('controls-bar', ControlsBar);

/***/ }),

/***/ "./src/components/work-zone.js":
/*!*************************************!*\
  !*** ./src/components/work-zone.js ***!
  \*************************************/
/***/ (() => {

class WorkZone extends HTMLElement {
  connectedCallback() {
    this.attachShadow({mode:'open'});
    this.shadowRoot.innerHTML = `
      <style>
        :host { 
          display: block; 
          border: none; 
          height: 100%; 
          min-height: 300px;
          background:#f0f0f0; 
          position: relative;
          --ruler: 26px;
          --cell-px: 40;
          --units-per-cell: 10;
        }

        canvas {
          position: absolute;
          display: block;
          pointer-events: none;
        }

        #grid {
          position:absolute;
          left:  var(--ruler);
          top:   0;
          width:  calc(100% - var(--ruler));   /* ← явная ширина */
          height: calc(100% - var(--ruler));   /* ← явная высота */
          z-index: 0;
          background:#2b2f36;
        }

        .ruler-x {
          position:absolute;
          left:  var(--ruler);
          bottom:0;
          width: calc(100% - var(--ruler));    /* ← явная ширина */
          height: var(--ruler);
          z-index: 1;
          background:#4b4f56;
        }

        .ruler-y {
          position:absolute;
          left:0; top:0;
          width: var(--ruler);
          height: calc(100% - var(--ruler));   /* ← явная высота */
          z-index:1;
          background:#4b4f56;
        }

        .corner{
          position: absolute; 
          left: 0; 
          bottom: 0; 
          width: var(--ruler);
          height: var(--ruler);
          background: #4b4f56; 
          z-index: 1;
          pointer-events:none;
        }

        .divider{
          position:absolute;
          left:0; top:0;
          width:100%;;
          height:0;                            /* задаём из JS */
          pointer-events:none;
          z-index:2;                           /* выше сетки */
          background:
            linear-gradient(to bottom,
              rgba(255,255,255,.10),
              rgba(255,255,255,0));            /* очень деликатно */
          box-shadow: inset 0 -1px 0 rgba(255,255,255,.08); /* тонкая линия внизу */
        }
        
        svg { position: absolute; top: 0; left: 0; cursor: grab; z-index: 3; }
      </style>

      <div class="divider" id="divider" aria-hidden="true"></div>
      <canvas id="grid"></canvas>
      <canvas class="ruler-x"></canvas>
      <canvas class="ruler-y"></canvas>
      <canvas class="corner" id="corner"></canvas>
    `;

    this.$grid = this.shadowRoot.getElementById('grid');
    this.$rx = this.shadowRoot.querySelector('.ruler-x');
    this.$ry = this.shadowRoot.querySelector('.ruler-y');
    this.$corner = this.shadowRoot.getElementById('corner');
    this.$divider = this.shadowRoot.getElementById('divider');

    const ro = new ResizeObserver(() => this.layoutAndDraw());
    ro.observe(this);
    this._ro = ro;
    requestAnimationFrame(() => this.layoutAndDraw());
  }

  disconnectedCallback(){ this._ro?.disconnect(); }

  /* ===== раскладка и отрисовка ===== */
  layoutAndDraw(){
    const dpr = Math.max(1, window.devicePixelRatio || 1);

    const cs = getComputedStyle(this);
    const cell  = parseFloat(cs.getPropertyValue('--cell-px')) || 40;
    const ruler = parseFloat(cs.getPropertyValue('--ruler'))   || 26;

    const hostRect = this.getBoundingClientRect();
    const availW = hostRect.width  - ruler;        
    const availH = hostRect.height - ruler;

    const snapY = availH % cell;                   // сколько «лишнего» внизу
    const snapX = 0;  

    this.$grid.style.top    = snapY ? `${snapY}px` : '0px';
    this.$grid.style.height = `calc(100% - var(--ruler) - ${snapY}px)`;

    this.$ry.style.top      = this.$grid.style.top;
    this.$ry.style.height   = this.$grid.style.height;

    this.$divider.style.height  = `${snapY}px`;
    this.$divider.style.display = snapY ? 'block' : 'none';

    const fit = (el) => {
      const r = el.getBoundingClientRect();
      el.width  = Math.max(1, Math.floor(r.width  * dpr));
      el.height = Math.max(1, Math.floor(r.height * dpr));
      const ctx = el.getContext('2d');
      ctx.setTransform(dpr,0,0,dpr,0,0); // рисуем в CSS-px
      return ctx;
    };

    this._ctxGrid = fit(this.$grid);
    this._ctxX = fit(this.$rx);
    this._ctxY = fit(this.$ry);
    this._ctxCorner = fit(this.$corner);

    this.drawGrid();
    this.drawRulerX();
    this.drawRulerY();
    this.drawCorner();
  }

  drawCorner() {
    const ctx = this._ctxCorner;
    const r = this.$corner.getBoundingClientRect();
    const w = r.width, h = r.height;

    ctx.fillStyle = '#e1e3e6';
    ctx.font = '12px system-ui,-apple-system, Segoe UI, Roboto, Inter, Arial';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';

    ctx.fillText('0', w / 2, h / 2);
  }

  drawGrid(){
    const ctx = this._ctxGrid;
    const r = this.$grid.getBoundingClientRect();
    const w = r.width, h = r.height;
    const cell = parseFloat(getComputedStyle(this).getPropertyValue('--cell-px')) || 40;

    // фон
    ctx.fillStyle = '#2b2f36';
    ctx.fillRect(0,0,w,h);

    // линии
    const majorEach = 5; // каждая 5-я толще
    for (let x = 0, i=0; x <= w+0.5; x += cell, i++){
      ctx.beginPath();
      ctx.lineWidth = (i % majorEach === 0) ? 1.2 : 1;
      ctx.strokeStyle = (i % majorEach === 0) ? 'rgba(255,255,255,.18)' : 'rgba(255,255,255,.10)';
      ctx.moveTo(Math.floor(x)+0.5, 0);
      ctx.lineTo(Math.floor(x)+0.5, h);
      ctx.stroke();
    }
    for (let y = 0, j=0; y <= h+0.5; y += cell, j++){
      ctx.beginPath();
      ctx.lineWidth = (j % majorEach === 0) ? 1.2 : 1;
      ctx.strokeStyle = (j % majorEach === 0) ? 'rgba(255,255,255,.18)' : 'rgba(255,255,255,.10)';
      ctx.moveTo(0, Math.floor(y)+0.5);
      ctx.lineTo(w, Math.floor(y)+0.5);
      ctx.stroke();
    }
  }

  drawRulerX(){
    const ctx = this._ctxX;
    const w = this.$rx.getBoundingClientRect().width;
    const h = this.$rx.getBoundingClientRect().height;
    const cell  = parseFloat(getComputedStyle(this).getPropertyValue('--cell-px')) || 40;
    const units = parseFloat(getComputedStyle(this).getPropertyValue('--units-per-cell')) || 10;

    // фон
    ctx.clearRect(0,0,w,h);
    ctx.fillStyle = '#4b4f56';
    ctx.fillRect(0,0,w,h);

    // подписи без рисок
    ctx.fillStyle = '#e1e3e6';
    ctx.font = '12px system-ui,-apple-system,Segoe UI,Roboto,Inter,Arial';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';

    for (let x = cell, i = 1; x <= w + 0.5; x += cell, i++){
      const X = Math.floor(x) + 0.5;      // пиксель-перфект кратоклеточное выравнивание
      ctx.fillText(String(i * units), X, h / 2);
    }
  }

  drawRulerY(){
    const ctx = this._ctxY;
    const w = this.$ry.getBoundingClientRect().width;
    const h = this.$ry.getBoundingClientRect().height;
    const cell  = parseFloat(getComputedStyle(this).getPropertyValue('--cell-px')) || 40;
    const units = parseFloat(getComputedStyle(this).getPropertyValue('--units-per-cell')) || 10;

    // фон
    ctx.clearRect(0,0,w,h);
    ctx.fillStyle = '#4b4f56';
    ctx.fillRect(0,0,w,h);

    // подписи без рисок (0 — внизу)
    ctx.fillStyle = '#e1e3e6';
    ctx.font = '12px system-ui,-apple-system,Segoe UI,Roboto,Inter,Arial';
    ctx.textAlign = 'left';
    ctx.textBaseline = 'middle';

    const steps = Math.round(h / cell);

    for (let i = 1; i < steps; i++){
      // y на центр риски: одна клетка выше низа, две клетки выше и т.д.
      const y = Math.floor(h - i * cell) + 0.5;
      const label = i * units;
      ctx.fillText(String(label), 4, y);
    }
  }

  _gridBounds(svgWidth = 0, svgHeight = 0) {
    const host = this.getBoundingClientRect();
    const grid = this.$grid.getBoundingClientRect();
    const minLeft = grid.left - host.left;
    const minTop  = grid.top  - host.top;
    const maxLeft = minLeft + grid.width  - svgWidth;
    const maxTop  = minTop  + grid.height - svgHeight;
    return { minLeft, minTop, maxLeft, maxTop };
  }

  startDragFromBuffer(e, polygonData) {
    e.preventDefault();
    const rect = this.shadowRoot.host.getBoundingClientRect();
    const svg = this.addPolygon(polygonData, e.clientX - rect.left, e.clientY - rect.top);

    const offsetX = e.clientX - svg.getBoundingClientRect().left;
    const offsetY = e.clientY - svg.getBoundingClientRect().top;

    const onMouseMove = ev => {
      const svgRect = svg.getBoundingClientRect();
      const { minLeft, maxLeft, maxTop } =
        this._gridBounds(svgRect.width, svgRect.height);

      let left = ev.clientX - rect.left - offsetX;
      let top  = ev.clientY - rect.top  - offsetY;

      left = Math.max(minLeft, Math.min(left, maxLeft));
      top  = Math.min(top, maxTop); 

      svg.style.left = `${left}px`;
      svg.style.top  = `${top}px`;
    };
    
    const onMouseUp = eve => {
      const workRect = this.getBoundingClientRect();
      const svgRect  = svg.getBoundingClientRect();
      const poly     = svg.querySelector('polygon');      // сам полигон
      const polyRect = poly.getBoundingClientRect();

      const gridTopLocal = this.$grid.offsetTop;          // низ divider'а в лок.коорд. host
      const polyTopLocal = polyRect.top - workRect.top;   // верх полигона относительно host

      // 1) Любая часть полигона ушла в буфер → убрать
      if (polyTopLocal < 0) {
        svg.remove();
      }
      // 2) Полигон в зоне divider (но не в буфере) → щёлкнуть к сетке
      else if (polyTopLocal < gridTopLocal) {
        const offsetInSvg = polyRect.top - svgRect.top;   // смещение верха полигона внутри svg
        const targetTop   = gridTopLocal - offsetInSvg;   // делаем так, чтобы верх полигона = gridTop
        svg.style.top = `${Math.round(targetTop)}px`;
      }
      
      document.removeEventListener('mousemove', onMouseMove);
      document.removeEventListener('mouseup', onMouseUp);
    };

    document.addEventListener('mousemove', onMouseMove);
    document.addEventListener('mouseup', onMouseUp);
  }

  addPolygon(polygonData, x, y) {
    const svgNS = "http://www.w3.org/2000/svg";
    const svg = document.createElementNS(svgNS, "svg");
    svg.setAttribute("width", 120);
    svg.setAttribute("height", 90);
    svg.style.position = "absolute";
    svg.style.left = `${x - 60}px`;
    svg.style.top = `${y - 45}px`;

    const polygon = document.createElementNS(svgNS, "polygon");
    polygon.setAttribute(
      "points", 
      polygonData.points.map(pt => `${pt.x}, ${pt.y}`).join(" "));
    polygon.setAttribute("fill", polygonData.fill);
    polygon.setAttribute("stroke", polygonData.stroke);
    polygon.setAttribute("stroke-width", 1);

    svg.appendChild(polygon);
    this.shadowRoot.appendChild(svg);

    svg.addEventListener('mousedown', e => {
      this.startDrag(e, svg);
    });
    return svg;
  }

  startDrag(e, svg) {
    e.preventDefault();
    const rect = this.shadowRoot.host.getBoundingClientRect();
    const offsetX = e.clientX - svg.getBoundingClientRect().left;
    const offsetY = e.clientY - svg.getBoundingClientRect().top;

    const onMouseMove = (ev) => {
    let newLeft = ev.clientX - rect.left - offsetX;
    let newTop = ev.clientY - rect.top - offsetY;

    if (newLeft < 0) newLeft = 0;
    if (newLeft + svg.offsetWidth > rect.width) newLeft = rect.width - svg.offsetWidth;

    if (newTop < 0) newTop = 0;
    if (newTop + svg.offsetHeight > rect.height) newTop = rect.height - svg.offsetHeight;

    svg.style.left = `${newLeft}px`;
    svg.style.top = `${newTop}px`;
    };
    
    const onMouseUp = () => {
      document.removeEventListener('mousemove', onMouseMove);
      document.removeEventListener('mouseup', onMouseUp);
    };

    document.addEventListener('mousemove', onMouseMove);
    document.addEventListener('mouseup', onMouseUp);
  }

  //set polygons(v){ this._ploys=v||[]; } set view(v){ this._view=v; }
}
customElements.define('work-zone', WorkZone);

/***/ }),

/***/ "./src/store.js":
/*!**********************!*\
  !*** ./src/store.js ***!
  \**********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   setBuffer: () => (/* binding */ setBuffer),
/* harmony export */   store: () => (/* binding */ store)
/* harmony export */ });
const store = {
  buffer: [],
  work: [],
};

const setBuffer = (list) => {
  store.buffer = list;
};

/***/ }),

/***/ "./src/styles/main.css":
/*!*****************************!*\
  !*** ./src/styles/main.css ***!
  \*****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! !../../node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js */ "./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js");
/* harmony import */ var _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! !../../node_modules/style-loader/dist/runtime/styleDomAPI.js */ "./node_modules/style-loader/dist/runtime/styleDomAPI.js");
/* harmony import */ var _node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! !../../node_modules/style-loader/dist/runtime/insertBySelector.js */ "./node_modules/style-loader/dist/runtime/insertBySelector.js");
/* harmony import */ var _node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! !../../node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js */ "./node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js");
/* harmony import */ var _node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var _node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! !../../node_modules/style-loader/dist/runtime/insertStyleElement.js */ "./node_modules/style-loader/dist/runtime/insertStyleElement.js");
/* harmony import */ var _node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4__);
/* harmony import */ var _node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! !../../node_modules/style-loader/dist/runtime/styleTagTransform.js */ "./node_modules/style-loader/dist/runtime/styleTagTransform.js");
/* harmony import */ var _node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5__);
/* harmony import */ var _node_modules_css_loader_dist_cjs_js_main_css__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! !!../../node_modules/css-loader/dist/cjs.js!./main.css */ "./node_modules/css-loader/dist/cjs.js!./src/styles/main.css");

      
      
      
      
      
      
      
      
      

var options = {};

options.styleTagTransform = (_node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5___default());
options.setAttributes = (_node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3___default());
options.insert = _node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2___default().bind(null, "head");
options.domAPI = (_node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1___default());
options.insertStyleElement = (_node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4___default());

var update = _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default()(_node_modules_css_loader_dist_cjs_js_main_css__WEBPACK_IMPORTED_MODULE_6__["default"], options);




       /* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_node_modules_css_loader_dist_cjs_js_main_css__WEBPACK_IMPORTED_MODULE_6__["default"] && _node_modules_css_loader_dist_cjs_js_main_css__WEBPACK_IMPORTED_MODULE_6__["default"].locals ? _node_modules_css_loader_dist_cjs_js_main_css__WEBPACK_IMPORTED_MODULE_6__["default"].locals : undefined);


/***/ }),

/***/ "./src/utils/polygen.js":
/*!******************************!*\
  !*** ./src/utils/polygen.js ***!
  \******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   makeManyConvex: () => (/* binding */ makeManyConvex),
/* harmony export */   makeManySimple: () => (/* binding */ makeManySimple),
/* harmony export */   makePolyConvex: () => (/* binding */ makePolyConvex),
/* harmony export */   makePolySimple: () => (/* binding */ makePolySimple),
/* harmony export */   randInt: () => (/* binding */ randInt)
/* harmony export */ });
const randInt = (a, b) => a + Math.floor(Math.random() * (b - a +1));

function normalizePolygon(pts, svgWidth = 120, svgHeight = 90, padding = 4) {
  const xs = pts.map(p => p.x);
  const ys = pts.map(p => p.y);

  const minX = Math.min(...xs);
  const maxX = Math.max(...xs);
  const minY = Math.min(...ys);
  const maxY = Math.max(...ys);

  const polyWidth = maxX - minX;
  const polyHeight = maxY - minY;

  const scaleX = (svgWidth - 2*padding) / (polyWidth || 1);
  const scaleY = (svgHeight - 2*padding) / (polyHeight || 1);
  const scale = Math.min(scaleX, scaleY);

  const offsetX = padding - minX*scale;
  const offsetY = padding - minY*scale;

  return pts.map(p => ({
    x: p.x*scale + offsetX,
    y: p.y*scale + offsetY
  }));
}

function segmentsIntersect(a, b, c, d) {
  const cross = (p1, p2, p3) =>
    (p2.x - p1.x) * (p3.y - p1.y) - (p2.y - p1.y) * (p3.x - p1.x);

  const d1 = cross(a, b, c);
  const d2 = cross(a, b, d);
  const d3 = cross(c, d, a);
  const d4 = cross(c ,d, b);

  return (d1 * d2 < 0) && (d3 * d4 < 0);
}

function isSimplePolygon(pts) {
  const n = pts.length;
  for (let i = 0; i < n; i++) {
    const a1 = pts[i];
    const b1 = pts[(i+1)%n];
    for (let j = i+1; j < n; j++) {
      if (Math.abs(i-j) <= 1 || (i===0 && j===n-1) || (i===n-1 && j===0)) continue;
      const a2 = pts[j];
      const b2 = pts[(j+1)%n];
      if (segmentsIntersect(a1, b1, a2, b2)) return false;
    }
  }
  return true;
}

function isConvexPolygon(pts) {
  const n = pts.length;
  if (n < 3) return false;
  let sign = 0;

  for (let i = 0; i < n; i++) {
    const a = pts[i];
    const b = pts[(i + 1) % n];
    const c = pts[(i + 2) % n];

    const cross = (b.x - a.x)*(c.y - b.y) - (b.y - a.y)*(c.x - b.x);

    if (Math.abs(cross) > 1e-8) {
      const s = Math.sign(cross);
      if (sign === 0) sign = s;
      else if (s !== sign) return false;
    }
  }

  console.log('gh');
  return true;
}

function isAngleEnough(pts, minAngleDeg = 15) {
  const n = pts.length;
  for (let i = 0; i < n; i++) {
    const a = pts[i];
    const b = pts[(i + 1) % n];
    const c = pts[(i + 2) % n];

    const v1 = { x: b.x - a.x, y: b.y - a.y };
    const v2 = { x: c.x - b.x, y: c.y - b.y };

    const cosAngle = (v1.x * v2.x + v1.y * v2.y) / (Math.hypot(v1.x, v1.y) * Math.hypot(v2.x, v2.y));
    const angleDeg = Math.acos(Math.min(Math.max(cosAngle, -1), 1)) * 180 / Math.PI;

    if (angleDeg < minAngleDeg) return false;
  }
  return true;
}

function isDistanceEnough(pts, dMin = 25) {
  const n = pts.length;
  for (let i = 0; i < n; i++) {
    const a = pts[i];
    const b = pts[(i + 1) % n];
    const dist = Math.hypot(b.x - a.x, b.y - a.y);
    if (dist < dMin) return false;
  }
  return true;
}

function makePolySimple() {
  const n = randInt(3, 8);
  const rMin = 25, rMax = 50;
  let pts;

  do {
    const angles = Array.from({length:n}, () => Math.random() * 2*Math.PI).sort((a,b)=>a-b);
    pts = angles.map(t => {
      const r = rMin + Math.random()*(rMax - rMin);
      return {
        x: r * Math.cos(t),
        y: r * Math.sin(t)
      };
    });
  } while (
    !isSimplePolygon(pts) ||
    !isAngleEnough(pts) ||
    !isDistanceEnough(pts)
  );

  pts = normalizePolygon(pts, 120, 90, 8);

  const h = randInt(0,360);
  return {
    id: `p_${crypto.randomUUID ?.() || Date.now() + ' ' + Math.random()}`,
    points: pts,
    fill: `hsl(${h} 70% 55%)`,
    stroke: 'rgba(0,0,0.25)'
  };
} 

function makePolyConvex() {
  let pts;
  const n = randInt(3, 8);
  const rMin = 25, rMax = 45;
  const r = (rMin + rMax)/2;

  do {
    pts = [];
    let angleStep = (2 * Math.PI) / n;
    for (let i = 0; i < n; i++) {
      const angle = i * angleStep + (Math.random() - 0.5) * angleStep * 0.5; // разброс ±25%
      const r = rMin + Math.random() * (rMax - rMin) * 0.25;
      pts.push({ x: r * Math.cos(angle), y: r * Math.sin(angle) });
    }
  } while (!isConvexPolygon(pts) || !isSimplePolygon(pts));

  pts = normalizePolygon(pts, 120, 90, 8);

  const h = randInt(0, 360);

  return {
    id: `p_${crypto.randomUUID ?.() || Date.now() + ' ' + Math.random()}`,
    points: pts,
    fill: `hsl(${h} 70% 55%)`,
    stroke: 'rgba(0,0,0.25)'
  };
} 

function makeManySimple() {
  return Array.from({ length: randInt(5, 20) }, makePolySimple);
}

function makeManyConvex() {
  return Array.from({ length: randInt(5, 20) }, makePolyConvex);
}

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			id: moduleId,
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	(() => {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = (module) => {
/******/ 			var getter = module && module.__esModule ?
/******/ 				() => (module['default']) :
/******/ 				() => (module);
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/nonce */
/******/ 	(() => {
/******/ 		__webpack_require__.nc = undefined;
/******/ 	})();
/******/ 	
/************************************************************************/
var __webpack_exports__ = {};
// This entry needs to be wrapped in an IIFE because it needs to be in strict mode.
(() => {
"use strict";
/*!**********************!*\
  !*** ./src/index.js ***!
  \**********************/
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _styles_main_css__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./styles/main.css */ "./src/styles/main.css");
/* harmony import */ var _components_app_root_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./components/app-root.js */ "./src/components/app-root.js");


})();

/******/ })()
;
//# sourceMappingURL=main.js.map